package hackathon_2023_vendor_reviews

import (
	"fmt"
	"log"
	"os"
	"strconv"

	"github.com/go-gota/gota/dataframe"
)

type ReviewResponseItem struct {
	ID              string   `json:"id"`
	Entity          string   `json:"globalVendorCode"`
	OrderID         string   `json:"orderId"`
	Date            string   `json:"date"`
	Text            string   `json:"text"`
	Tags            []string `json:"tags"`
	Rating          float32  `json:"rating"`
	IsAutoGenerated bool     `json:"isAutoGenerated"`
	SuggestedReply  string   `json:"suggestedReply"`
}

type ReviewsResponse struct {
	HasPrevious   bool                  `json:"hasPrevious"`
	HasNext       bool                  `json:"hasNext"`
	Reviews       []ReviewResponseItem  `json:"reviews"`
	ReviewsDigest openAISummaryResponse `json:"reviewsDigest"`
}

type SummaryReview struct {
	Summary string `json:"summary"`
}

func getReviewsItems(limit int) map[string]*ReviewResponseItem {
	pwd, _ := os.Getwd()
	file, err := os.Open(pwd + "/data/reviews.csv")
	defer file.Close()
	if err != nil {
		log.Fatal(err)
	}
	df := dataframe.ReadCSV(file)

	reviews := df.Select([]string{"id", "order_id", "date", "review", "rating"})
	indexes := make([]int, limit)
	for i := 0; i < limit; i++ {
		indexes[i] = i
	}
	limitedRecords := reviews.Subset(indexes)
	reviewsMap := make(map[string]*ReviewResponseItem, limit)
	for i, item := range limitedRecords.Records() {
		// skip headers
		if i == 0 {
			continue
		}
		rating, _ := strconv.ParseFloat(item[4], 32)
		record := &ReviewResponseItem{
			ID:              item[0],
			Entity:          "",
			OrderID:         item[1],
			Date:            item[2],
			Text:            item[3],
			Rating:          float32(rating),
			IsAutoGenerated: false,
			SuggestedReply:  "",
		}
		reviewsMap[record.ID] = record
	}
	return reviewsMap
}
func getReviewsStatement(limit int) []string {
	pwd, _ := os.Getwd()
	file, err := os.Open(pwd + "/data/reviews.csv")
	defer file.Close()
	if err != nil {
		log.Fatal(err)
	}
	df := dataframe.ReadCSV(file)

	reviews := df.Select([]string{"review", "rating", "date"})
	indexes := make([]int, limit)
	for i := 0; i < limit; i++ {
		indexes[i] = i
	}
	limitedRecords := reviews.Subset(indexes)
	reviewsSlc := make([]string, 0, limit)
	for i, item := range limitedRecords.Records() {
		// skip headers
		if i == 0 {
			continue
		}
		record := fmt.Sprintf("Date:%s| Review: %s| Rating:%s", item[2], item[0], item[1])
		reviewsSlc = append(reviewsSlc, record)
	}
	return reviewsSlc
}
func getReviewsWithID(limit int) []string {
	pwd, _ := os.Getwd()
	file, err := os.Open(pwd + "/data/reviews.csv")
	defer file.Close()
	if err != nil {
		log.Fatal(err)
	}
	df := dataframe.ReadCSV(file)

	reviews := df.Select([]string{"id", "review", "rating"})
	indexes := make([]int, limit)
	for i := 0; i < limit; i++ {
		indexes[i] = i
	}
	limitedRecords := reviews.Subset(indexes)
	reviewsSlc := make([]string, 0, limit)
	for i, item := range limitedRecords.Records() {
		// skip headers
		if i == 0 {
			continue
		}
		record := fmt.Sprintf("id:%s, review: %s , rating:%s", item[0], item[1], item[2])
		reviewsSlc = append(reviewsSlc, record)
	}
	return reviewsSlc
}
func getSmartRelies(limit int) []string {
	pwd, _ := os.Getwd()
	file, err := os.Open(pwd + "/data/sample-replies.csv")
	defer file.Close()
	if err != nil {
		log.Fatal(err)
	}
	df := dataframe.ReadCSV(file)

	reviews := df.Select([]string{"review", "reply"})
	indexes := make([]int, limit)
	for i := 0; i < limit; i++ {
		indexes[i] = i
	}
	limitedRecords := reviews.Subset(indexes)
	reviewsSlc := make([]string, 0, limit)
	for i, item := range limitedRecords.Records() {
		// skip headers
		if i == 0 {
			continue
		}
		record := fmt.Sprintf("review: %s , reply:%s", item[0], item[1])
		reviewsSlc = append(reviewsSlc, record)
	}
	return reviewsSlc
}
